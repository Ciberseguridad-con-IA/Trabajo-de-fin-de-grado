# -*- coding: utf-8 -*-
"""Generacion dataset definciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AcdeTsmm7zLeDyleeGt9pdkYCCPX8u3i
"""

!pip install requests python-dotenv --quiet

import os
import re
import requests
from dotenv import load_dotenv
from huggingface_hub import InferenceClient
import json

from google.colab import drive
drive.mount('/content/drive')

# Carga las variables desde el archivo
load_dotenv("/content/drive/My Drive/TFG/.env")
#load_dotenv("/content/drive/Shareddrives/TFG/.env") #usad esto si no sois yo :D

DEEPINFRA_API_KEY = os.getenv("DEEPINFRA_API_KEY")
TOGETHER_API_KEY = os.getenv("TOGETHER_API_KEY")

"""https://deepinfra.com/dash/api_keys

https://api.together.ai/?_gl=1*xpc3i2*_gcl_au*NzMzMjA0ODc1LjE3NDMwOTk3NTk.*_ga*OTcwMzk4ODUwLjE3NDMwOTk3NTg.*_ga_BS43X21GZ2*MTc0MzA5OTc1Ny4xLjAuMTc0MzA5OTc1Ny4wLjAuMA..*_ga_BBHKJ5V8S0*MTc0MzA5OTc1Ny4xLjAuMTc0MzA5OTc1Ny4wLjAuMA..
"""

def extract_json(text):
    """Extrae y limpia el bloque JSON de la respuesta del modelo."""
    match = re.search(r"\{.*\}", text, re.DOTALL)
    if match:
        extracted = match.group(0)
        try:
            return json.loads(extracted)  # Intentar cargarlo directamente
        except json.JSONDecodeError:
            # Si falla, intentar limpiar caracteres no válidos
            cleaned_text = extracted.replace("\\_", "_")  # Corrige backslashes no deseados
            try:
                return json.loads(cleaned_text)
            except json.JSONDecodeError:
                return None
    return None

"""1. Recibir la pregunta
2. Identificar si la pregunta es sobre una definición
3. Si es una definicion responder y cortar el razonamiento
4. Si no es script hacer RAG
"""

def generate_qa_structure(topic: str, model: str = "mistralai/Mixtral-8x7B-Instruct-v0.1") -> dict:
    url = "https://api.together.xyz/v1/chat/completions"
    headers = {"Authorization": f"Bearer {TOGETHER_API_KEY}", "Content-Type": "application/json"}

    # Construcción del prompt que se enviará al modelo
    prompt = f"""Genera un JSON con:
    - "Question": Pregunta clara
    - "Complex_CoT": Pasos numerados (1., 2., 3.) como texto plano, NO objetos
    - "Response": Respuesta concisa

    Ejemplo:
    {{
        "Question": "¿Cómo X?",
        "Complex_CoT": "1. Paso uno\\n2. Paso dos\\n3. Paso tres",
        "Response": "Respuesta final"
    }}

    Es importante traducir todo al inglés.

    Tema: '{topic}'
    """

    data = {
        "model": model,
        "messages": [{"role": "system", "content": "You are a cybersecurity expert with advanced knowledge in penetration testing, vulnerability analysis, and exploit development. You specialize in guiding and explaining the process of solving VulnHub machines, focusing on practical methodologies, critical thinking, and step-by-step problem-solving strategies."},
                     {"role": "user", "content": prompt}],
        "temperature": 0.7,
        "max_tokens": 1000
    }

    response = requests.post(url, headers=headers, json=data)

    try:
        result = response.json()

        if "choices" not in result:
            print(f"❌ Error en la API: {result}")  # <-- Muestra el mensaje de error de la API
            return {
                "Question": topic,
                "Complex_CoT": "Error: Respuesta no válida de la API.",
                "Response": str(result)
            }

        text_output = result["choices"][0]["message"]["content"].strip()

        # Intentar extraer y decodificar el JSON
        json_response = extract_json(text_output)

        if json_response is None:
            raise json.JSONDecodeError("No se encontró un JSON válido", text_output, 0)

        # Conversión forzada a texto plano si Complex_CoT es un diccionario
        if isinstance(json_response.get("Complex_CoT"), dict):
            steps = [f"{i+1}. {v}" for i, (k, v) in enumerate(json_response["Complex_CoT"].items())]
            json_response["Complex_CoT"] = "\n".join(steps)

        return json_response

    except (json.JSONDecodeError, KeyError) as e:
        print(f"⚠️ Excepción atrapada: {e}")
        return {
            "Question": topic,
            "Complex_CoT": "Error: No se pudo procesar correctamente la respuesta.",
            "Response": str(result)
        }

# Leer líneas del archivo y generar QA para cada una
def process_file(input_filepath: str, output_filepath: str):
    results = []

    with open(input_filepath, "r", encoding="utf-8") as file:
        topics = [line.strip() for line in file if line.strip()]

    for topic in topics:
        result = generate_qa_structure(topic)
        results.append(result)

    with open(output_filepath, "w", encoding="utf-8") as outfile:
        json.dump(results, outfile, indent=2, ensure_ascii=False)

    print(f"Se han guardado los resultados en {output_filepath}")

# Definir rutas de los archivos
input_file = "/content/drive/My Drive/TFG/topics.txt"  # Archivo de entrada
output_file = "/content/drive/My Drive/TFG/generated_qa.json"  # Archivo de salida

# Ejecutar el procesamiento
test_run = False  # Cambiar a False para ejecutar en todo el archivo
if test_run:
    with open(input_file, "r", encoding="utf-8") as file:
        first_line = file.readline().strip()
    print(generate_qa_structure(first_line))
else:
    process_file(input_file, output_file)